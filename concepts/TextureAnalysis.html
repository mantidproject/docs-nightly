<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Texture Analysis Theory</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/bootstrap-sphinx.css?v=fadd4351" />
    <link rel="stylesheet" type="text/css" href="../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=77160d70" />
    <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
    <script src="../_static/documentation_options.js?v=1d22286e"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Units" href="UnitFactory.html" />
    <link rel="prev" title="Table Workspaces" href="TableWorkspaces.html" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-59110517-1', 'auto');
  ga('send', 'pageview');

</script>


  </head><body>





  <div id="navbar" class="navbar navbar-default ">
    <div class="container">
      <div class="navbar-header">
        
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="http://www.mantidproject.org">
           </a>
        <span class="navbar-text navbar-version pull-left"><b>6.14</b></span>
      </div>

      
        <div class="collapse navbar-collapse nav-collapse">
      
          <ul class="nav navbar-nav">
            <li class="divider-vertical"></li>
            
                <li><a href="https://www.mantidproject.org">Home</a></li>
                <li><a href="https://download.mantidproject.org">Download</a></li>
                <li><a href="https://docs.mantidproject.org">Documentation</a></li>
                <li><a href="https://www.mantidproject.org/contact">Contact Us</a></li>
            
            
              
              
            
            
            
            
          </ul>
              
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
            </div>
    </div>
    <p>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation</a> &#187;</li>
        
            <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Concepts</a> &#187;</li>
          
        
        
          
            <li class="nav-item nav-item-this"><a href="">Texture Analysis Theory</a></li>
          
        
      </ul>
    </div> </p>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <p><span class="math notranslate nohighlight">\(\renewcommand\AA{\unicode{x212B}}\)</span></p>
<section id="texture-analysis-theory">
<span id="textureanalysis"></span><h1><a class="toc-backref" href="#id11" role="doc-backlink">Texture Analysis Theory</a><a class="headerlink" href="#texture-analysis-theory" title="Link to this heading">¶</a></h1>
<nav class="contents" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#texture-analysis-theory" id="id11">Texture Analysis Theory</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction-to-texture-analysis" id="id12">Introduction to Texture Analysis</a></p></li>
<li><p><a class="reference internal" href="#interpreting-pole-figures" id="id13">Interpreting Pole Figures</a></p></li>
<li><p><a class="reference internal" href="#generating-pole-figures" id="id14">Generating Pole Figures</a></p></li>
<li><p><a class="reference internal" href="#pole-figure-resolution-and-coverage" id="id15">Pole Figure Resolution and Coverage</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#producing-pole-figures-within-mantid" id="id16">Producing Pole Figures within Mantid</a></p>
<ul>
<li><p><a class="reference internal" href="#introduction-to-sample-shape-material-and-orientation" id="id17">Introduction to Sample Shape, Material, and Orientation</a></p>
<ul>
<li><p><a class="reference internal" href="#reference-workspace" id="id18">Reference Workspace</a></p></li>
<li><p><a class="reference internal" href="#orientation-files" id="id19">Orientation Files</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#absorption-correction" id="id20">Absorption Correction</a></p></li>
<li><p><a class="reference internal" href="#focusing" id="id21">Focusing</a></p></li>
<li><p><a class="reference internal" href="#fitting" id="id22">Fitting</a></p></li>
<li><p><a class="reference internal" href="#pole-figure-creation" id="id23">Pole Figure creation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#references" id="id24">References</a></p></li>
</ul>
</nav>
<section id="introduction-to-texture-analysis">
<h2><a class="toc-backref" href="#id12" role="doc-backlink">Introduction to Texture Analysis</a><a class="headerlink" href="#introduction-to-texture-analysis" title="Link to this heading">¶</a></h2>
<p>For argument’s sake, let’s say you have some sample and you are interested in knowing it’s crystallographic texture – that is to say, you want to know what
the relationship is between the macroscopic dimensions of your sample and some given crystallographic plane e.g. <span class="math notranslate nohighlight">\((100)\)</span>?</p>
<figure class="align-default" id="id3">
<img alt="An example cuboid sample and a corresponding mantid representation" src="../_images/texture-example-sample.png" />
<figcaption>
<p><span class="caption-text">Figure 1 - An example cuboid sample and a corresponding mantid representation, the intrinsic directions corresponding to: the Rolling Direction (RD);
the Traverse Direction (TD); and the Normal Direction (ND), are shown with the red, blue and green arrows.</span><a class="headerlink" href="#id3" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>Taking the above sample as example, you can see that, by virtue of being a cuboid, the sample has a unique height, width and length.
These directions may or may not also be correlated with some processing procedure (e.g. in this case: the length is the Rolling Direction;
The width is the Traverse Direction and the height is the Normal Direction).</p>
<p>Some subsequent questions you might have about your sample are:</p>
<ul class="simple">
<li><p>How is the underlying crystal structure orientated in relation to these macroscopic directions?</p></li>
<li><p>Does this relationship change when looking at different points within the sample?</p></li>
<li><p>Is this relationship a product of the processing?</p></li>
</ul>
<p>These might be especially of interest to you if critical mechanical properties of the material are related to the orientation/size of crystal grains.
These are the questions which the texture analysis pipeline in Mantid seeks to help you answer.</p>
<p>Within Mantid, you are able to produce Pole Figures for different Bragg reflections.
The experimental pole figure plot will typically show the fitted intensity parameter of the peak associated with that reflection, along different macroscopic sample directions.
As each Bragg reflection corresponds to a specific set of crystallographic planes with defined orientations relative to the crystal structure, the intensity
of a given Bragg peak in different macroscopic directions provides information on the alignment of that set of atomic planes to that sample direction
(within the volume of sample both: illuminated by the beam and; visible by the detectors).</p>
<p>By moving this illuminated volume (gauge volume) within the sample and observing the change to the reflection intensities, it is further possible to investigate how
the crystallographic texture changes throughout a sample. If you then repeat these experiments with different sample processing, you could then determine the extent to
which the observed texture is a product of the specific processes used. Additionally, you are able to produce similar plots but looking at other features of the Bragg peak,
such as peak position for strain mapping.</p>
<p>Once these experimental pole figures have been produced within Mantid, the onus is on the user to take the experimental pole figure data and perform the rigorous
analysis elsewhere, to generate theoretical pole figures and/or orientation distribution functions, to draw ultimate conclusions regarding crystallographic texture.</p>
<p>Below, we will first provide an explanation as to what you are looking at when you see a pole figure and why that is of interest. From here, we will cover a basic overview of
how the experimental data collection is done and how this data is processed to create the pole figure. We will then finally provide some examples of how this can be done
within Mantid using some scripts as example.</p>
</section>
<section id="interpreting-pole-figures">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Interpreting Pole Figures</a><a class="headerlink" href="#interpreting-pole-figures" title="Link to this heading">¶</a></h2>
<p>A way to interpret the pole figure is to imagine that your sample is placed within a sphere.
Each unique direction relative to your sample will intercept the sphere at a unique point – these points are the poles (like the North and South Poles of the Earth).</p>
<p>If we imagine being able to sample the intensity of your given reflection peak in every possible direction, this would correspond to sampling the surface of the sphere.
Plotting the intensity associated with a Bragg peak in each of these direction onto this sphere, we would get a complete 3D representation of how the intensity changes along all macroscopic sample directions.
This is shown in the first of the two graphics below.
The second graphic then shows the same intensity plot, but with the intensity values convolved into the radial coordinate,
which gives another spatial representation of the intensity of the bragg reflection as a function of direction around the sample.</p>
<table class="docutils align-center">
<colgroup>
<col style="width: 50.0%" />
<col style="width: 50.0%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><figure class="align-default" id="id4">
<a class="reference internal image-reference" href="../_images/texture-direction-sphere.gif"><img alt="Direction vectors trace out sphere" src="../_images/texture-direction-sphere.gif" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 2 - Direction vectors around a sample.</span><a class="headerlink" href="#id4" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
<td><figure class="align-default" id="id5">
<a class="reference internal image-reference" href="../_images/texture-direction-peaks.gif"><img alt="Direction vectors with intensity" src="../_images/texture-direction-peaks.gif" style="width: 90%;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 3 - Directions convolved with intensity.</span><a class="headerlink" href="#id5" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</td>
</tr>
</tbody>
</table>
<p>Much like how maps of the world provide 2D representations of the 3D globe, we can do the same thing by projecting this 3D pole figure down into a 2D pole figure.
The below graphic shows the relationship between the 2D pole figure which are commonly encountered and that 3D sphere which defines all unique directions around a sample.</p>
<figure class="align-default" id="id6">
<a class="reference internal image-reference" href="../_images/texture-pole-figure-interpretation.gif"><img alt="GIF showing the relationship between the 3D and 2D representations of the pole figure" src="../_images/texture-pole-figure-interpretation.gif" style="width: 500px;" />
</a>
<figcaption>
<p><span class="caption-text">Figure 4 - Animation showing how the relationship between the 3D and 2D representations of the pole figure.</span><a class="headerlink" href="#id6" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The surface of this sphere is again coloured by the intensity of a selected bragg peak, giving a 3D pole figure.
Additionally, the graphic shows the distortion between this spherical representation and the intensity convolved representation.</p>
<p>The way the 3D pole figure is projected into the plane matters, as different transformations compromise on which geometric properties of the 3D surface are preseverved in the 2D representation
(e.g. the azimuthal and stereographic projections provided maintain angular relationships, which can be useful for viewing the symmetry relationships of poles).</p>
<p>In reality, we cannot sample every possible point on this sphere – we are experimentally confined by our detector geometries and finite time, to only sample a subset of these points.
These are the points which are displayed in the experimental pole figure scatter plot.
(It is possible to interpolate between these points to get a more continuous representation – which is given as an option to display the contour plot instead, but it is
worth stressing that this does not provide an suitable replacement for a robust calculation of a theoretical pole figure).</p>
<figure class="align-default" id="id7">
<img alt="Image comparing the scatter plot pole figure and the contour interpolation" src="../_images/texture-pole-figure-displays.png" />
<figcaption>
<p><span class="caption-text">Figure 5 - Image comparing the scatter plot pole figure and the contour interpolation</span><a class="headerlink" href="#id7" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="generating-pole-figures">
<h2><a class="toc-backref" href="#id14" role="doc-backlink">Generating Pole Figures</a><a class="headerlink" href="#generating-pole-figures" title="Link to this heading">¶</a></h2>
<p>Here we provide two animations which aim to explain how the experimental pole figures are created.</p>
<p>The first of the these two, the below figure, shows how the orientation of the detectors, relative to the sample, relates to the 3D and 2D pole figures.
The top two graphics show the individual scattering vectors for two of the detectors, depicted as gold and pink arrows,
and how the intrinsic directions of the sample move relative to these scattering vectors as the orientation of that sample changes during the experiment.
The bottom left graphic then shows, in the fixed, intrinsic sample frame of the pole figures, the corresponding relative movement of these scattering vectors.
Here the sphere is coloured with the intensity of the complete pole figure.
The bottom right graphic shows how the scattering vectors (corresponding to all the 30 detectors) are then projected into the 2D pole figure, again, the pink and gold detectors are highlighted here.</p>
<figure class="align-default" id="id8">
<img alt="GIF showing the relationship between the experimental geometry and the pole figure" src="../_images/texture-pole-figure-lookup.gif" />
<figcaption>
<p><span class="caption-text">Figure 6 - Animation showing the relationship between the experimental geometry and the pole figure</span><a class="headerlink" href="#id8" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The second of these graphics, again below, shows how the intensities are determined for the points in the experimental pole figure.
Here the two detector banks have been split up into 3x5 grids. The summed spectra for each block in the grid is collected over the course of the experiment and these are shown on the left and right plots.
The pole figure for a given reflection is then generated by fitting a peak to the desired reflection and reading out the peak parameter of interest which, in the case shown, is the integrated intensity.
The bottom plots show these integrated intensity values on the actual detector banks and how these are projected into the 2D pole figure.</p>
<figure class="align-default" id="id9">
<img alt="GIF showing how intensities are calculated for each detector in the pole figure" src="../_images/texture-pole-figure-detectors.gif" />
<figcaption>
<p><span class="caption-text">Figure 7 - Animation showing how intensities are calculated for each detector in the pole figure</span><a class="headerlink" href="#id9" title="Link to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="pole-figure-resolution-and-coverage">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Pole Figure Resolution and Coverage</a><a class="headerlink" href="#pole-figure-resolution-and-coverage" title="Link to this heading">¶</a></h2>
<p>A few factors will affect the final quality of the experimental pole figure data, with the two main considerations being how the detector banks are grouped and
for what sample orientations data is collected.</p>
<p>In mantid, the first of these – the detector groupings, can be decided after the experiment has been run.
The reality here (at least for ENGIN-X), is that although it is possible to generate an experimental pole figure using each individual detector pixel as a unique point,
the spectra collected from these may suffer as a result of poor signal-to-noise-ratio of those individual signals. This signal-to-noise-ratio can be improved by
grouping neighbouring pixels together, thus obtaining cleaner spectra to fit, at the trade off of angular resolution. Alternatively, beam access permitting, longer collection times
can be used to improve signal-to-noise, theoretically allowing these finer pixel groupings to be feasible. The below figure shows the same runs processed using
different detector groupings, and the effect this has on the pole figure coverage.</p>
<figure class="align-default" id="id10">
<img alt="Image showing pole figures using different detector groupings" src="../_images/texture-pole-figure-groupings.png" />
<figcaption>
<p><span class="caption-text">Figure 8 - Image showing pole figures using different detector groupings.</span><a class="headerlink" href="#id10" title="Link to this image">¶</a></p>
</figcaption>
</figure>
<p>The second factor – sample orientations, is something which perhaps requires more consideration before hitting <em>GO</em> on data collection. The factors to weigh up here are
optimising your balance of time vs uncertainty. If you are quite confident in some aspect of your texture (such as a known symmetry), you may be able to target your data
collection to obtain datasets with the detectors covering only a few key sectors in the pole figure, saving time by reducing the number of experimental runs.
In contrast, if the texture is unknown, the optimal strategy is most likely to be one where you obtain even coverage across the entire pole figure,
and you aim to do this in a time efficient manner, by minimising overlap of successive runs. Another consideration of this exploratory coverage, compared to a more targeted approach
is that you will likely end up with an experimental pole figure which has fewer data points around the actual regions of interest.
As such, again time permitting, a dual approach may prove advantageous for unknown textures, where a preliminary full coverage dataset is collect and, upon subsequent
inspection, addition runs are collected targeting the identified regions of interest.
A discussion of possible exploratory coverage schemes is given in <a class="footnote-reference brackets" href="#detbanks" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="producing-pole-figures-within-mantid">
<h1><a class="toc-backref" href="#id16" role="doc-backlink">Producing Pole Figures within Mantid</a><a class="headerlink" href="#producing-pole-figures-within-mantid" title="Link to this heading">¶</a></h1>
<p>The creation of experimental pole figures within Mantid can be achieved in two distinct workflows: either using scripts within the python interface or
through the Engineering Diffraction user interface. The application of the latter will be discussed separately in <a class="reference internal" href="../interfaces/diffraction/Engineering%20Diffraction.html#engineering-diffraction-ref"><span class="std std-ref">Engineering Diffraction</span></a>,
here we will focus on the scripting approach. It is worth noting that for practical application, the scripts offer the most time efficient workflow and, as such,
are probably the preferable approach for creating pole figures post-experiment. The user interface, contrastingly, offers a more interactive approach which lends itself to
processing and guiding the evolution of the experiment, as it is being conducted.</p>
<section id="introduction-to-sample-shape-material-and-orientation">
<h2><a class="toc-backref" href="#id17" role="doc-backlink">Introduction to Sample Shape, Material, and Orientation</a><a class="headerlink" href="#introduction-to-sample-shape-material-and-orientation" title="Link to this heading">¶</a></h2>
<p>A critical aspect in creating the experimental pole figure is having the correct representation of the sample, its shape, and its intrinsic directions for each dataset you process.
This is crucial because these are the factors which will determine where detector points are projected in the pole figure.
Getting these things right within mantid, should hopefully, not be too onerous, but care should be taken to make good records of the
physical layouts during the experiment to check your recreation in mantid.</p>
<p>The way the texture analysis has been designed in Mantid, is that each run’s workspace should contain the information about the sample shape and its orientation relative
to an initial reference position. It is then required, at the point of pole figure creation, to provide the intrinsic sample directions, in lab coordinates, for this
initial reference position. Typically, this is achieved by having the initial reference position as the sample mounted upon the goniometer of choice in its default “home” position.
The sample would ideally be aligned on the homed goniometer to have intrinsic directions aligned with simple, identifiable directions in the lab coordinates, which is often
intuitively done in practice (intrinsic directions are typically aligned with some topological features and these are oft aligned to be parallel or perpendicular to the beam).
If the sample is not so straightforwardly positioned in the reference state, some more care should be taken to get the definition of these initial directions correct.</p>
<p>From here, the transformation to each run’s sample orientation is exactly the same as the transformation defined by the moving the goniometer from its home state for that run.
On ENGINX, there are two main goniometers used - the Eulerian Cradle and the Cybaman. Extracting the state transformations for these two goniometers
setups is done with different approaches, but should provide coverage for a broad range of additional setups.</p>
<p>The general procedure for transfering these pieces of information onto the relevant workspaces is as follows. First define a “Reference Workspace” upon which the initial
sample shape and orientation can be saved (along with any information on material which might be used for absorption correction). Next, load in all the run workspaces
corresponding to this experiment. Load an orientation file to set the goniometer transformation on the individual workspaces. Finally, copy the sample definition across from the
reference workspace to each of the run workspaces.</p>
<p>This procedure is applied as part of the absorption script provided in the <a class="reference internal" href="#absorptioncorrectionsection"><span class="std std-ref">section below</span></a>. We also provide some additional notes and scripts
to aid in the setup of <a class="reference internal" href="#referenceworkspacesection"><span class="std std-ref">reference workspaces</span></a> and <a class="reference internal" href="#orientationsection"><span class="std std-ref">orientation files</span></a>.</p>
<section id="reference-workspace">
<span id="referenceworkspacesection"></span><h3><a class="toc-backref" href="#id18" role="doc-backlink">Reference Workspace</a><a class="headerlink" href="#reference-workspace" title="Link to this heading">¶</a></h3>
<p>The following script will allow the setup of the reference workspace.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.texture.correction.correction_model</span><span class="w"> </span><span class="kn">import</span> <span class="n">TextureCorrectionModel</span>

<span class="c1"># Create an example Reference Workspace</span>

<span class="c1"># set experiment name</span>
<span class="n">exp_name</span> <span class="o">=</span> <span class="s2">&quot;Example&quot;</span>

<span class="c1"># set the directory where your workflow files should be saved</span>
<span class="n">save_root</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\fedid12345\Engineering_Mantid&quot;</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_root</span><span class="si">}</span><span class="s2">\User\</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="n">instr</span> <span class="o">=</span> <span class="s2">&quot;ENGINX&quot;</span>

<span class="c1"># set shape info to either be a shape xml string or a file to an stl</span>
<span class="n">example_shape_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">&lt;hollow-cylinder id=&quot;A&quot;&gt;</span>
<span class="s2">&lt;centre-of-bottom-base x=&quot;-0.01315&quot; y=&quot;-0.01315&quot; z=&quot;-0.00756&quot; /&gt;</span>
<span class="s2">&lt;axis x=&quot;0.0&quot; y=&quot;0.0&quot; z=&quot;1.0&quot; /&gt;</span>
<span class="s2">&lt;inner-radius val=&quot;0.0145&quot; /&gt;</span>
<span class="s2">&lt;outer-radius val=&quot;0.0223&quot; /&gt;</span>
<span class="s2">&lt;height val=&quot;0.01512&quot; /&gt;</span>
<span class="s2">&lt;/hollow-cylinder&gt;</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">sample_material</span> <span class="o">=</span> <span class="s2">&quot;Zr&quot;</span>


<span class="n">model</span> <span class="o">=</span> <span class="n">TextureCorrectionModel</span><span class="p">()</span>
<span class="n">model</span><span class="o">.</span><span class="n">create_reference_ws</span><span class="p">(</span><span class="n">exp_name</span><span class="p">,</span> <span class="n">instr</span><span class="p">)</span>

<span class="c1"># if it ends with .stl assume we have been given the file path</span>
<span class="n">model</span><span class="o">.</span><span class="n">set_sample_info</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">reference_ws</span><span class="p">,</span> <span class="n">example_shape_info</span><span class="p">,</span> <span class="n">sample_material</span><span class="p">)</span>

<span class="c1"># save reference file</span>
<span class="n">model</span><span class="o">.</span><span class="n">save_reference_file</span><span class="p">(</span><span class="n">exp_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">root_dir</span><span class="p">)</span> <span class="c1"># just set group as None here</span>
</pre></div>
</div>
</section>
<section id="orientation-files">
<span id="orientationsection"></span><h3><a class="toc-backref" href="#id19" role="doc-backlink">Orientation Files</a><a class="headerlink" href="#orientation-files" title="Link to this heading">¶</a></h3>
<p>As discussed previously, the orientation information is expected to come from either the Eulerian Cradle or the Cybaman, but these two goniometers are handled broadly
by providing either a series of fixed rotations around known axes (cradle) or by providing a flattened transformation matrix corresponding to a more complicated
transformation (cybaman). The flag which controls this behaviour is <code class="docutils literal notranslate"><span class="pre">orient_file_is_euler</span></code>.</p>
<p>If this is <code class="docutils literal notranslate"><span class="pre">True</span></code>, the orientation file is expect to be a text file with a row for each run and, within each row, a rotation angle for each axis.
These axes are then defined by <code class="docutils literal notranslate"><span class="pre">euler_scheme</span></code>, taking a string of lab directions for the initial
axes of each goniometer axis. The sense of the rotation around these axes are then defined by <code class="docutils literal notranslate"><span class="pre">euler_axes_sense</span></code>, where the string given should be comma separated +/-1,
one for each axis, where rotations are counter-clockwise (1) or clockwise (-1).</p>
<p>If <code class="docutils literal notranslate"><span class="pre">orient_file_is_euler</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the orientation file is expected to be a text file with a row for each run and, within each row the first 9 values are expected to
be a “C-style” (row-major) flattened 3x3 transformation matrix. It is anticipated that this matrix would be extracted from the <cite>SscansS2</cite> software <a class="footnote-reference brackets" href="#sscanss" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>, and a script is provided below for converted
the transformation matrices from SscansS2 reference frame into mantid. In principle, a flattened matrix from any sample positioner could be given here instead.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># script to covert a file with flattened matrices that have been generated in sscanss (and</span>
<span class="c1"># thus us in the sscanss reference frame where beam = X, detector = Y, roof = Z) into a</span>
<span class="c1"># matrix that is in the mantid reference frame</span>

<span class="c1"># Just set the txt file path and the tell it the number of scan points there were and you</span>
<span class="c1"># will get a _mantid_point_n.txt file created for each point</span>


<span class="c1">#~~~~~~~~~~~~~~~~~ Setup ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="n">txt_file</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;path\to\file\Zirc_ring_pose_matrices.txt&quot;</span>
<span class="n">NUM_POINTS</span> <span class="o">=</span> <span class="mi">3</span>


<span class="c1">#~~~~~~~~~~~~~~~~~~ Script Execution ~~~~~~~~~~~~~~~~~~~~~~~~</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">txt_file</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
   <span class="n">goniometer_strings</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()]</span>

<span class="n">transformed_strings</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">convert_from_sscanss_frame</span><span class="p">(</span><span class="n">r_zxy</span><span class="p">):</span>
   <span class="c1"># Define M: matrix to convert vectors from XYZ to ZXY</span>
   <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># X in ZXY = Z in XYZ</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>  <span class="c1"># Y in ZXY = X in XYZ</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>   <span class="c1"># Z in ZXY = Y in XYZ</span>
   <span class="p">])</span>
   <span class="n">M_inv</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># since M is orthonormal</span>

   <span class="c1"># Apply the similarity transform in reverse express R in XYZ frame</span>
   <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">r_zxy</span> <span class="o">@</span> <span class="n">M</span>


<span class="k">for</span> <span class="n">gs</span> <span class="ow">in</span> <span class="n">goniometer_strings</span><span class="p">:</span>
   <span class="n">or_vals</span> <span class="o">=</span> <span class="n">gs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
   <span class="n">trans_vals</span> <span class="o">=</span> <span class="n">or_vals</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>
   <span class="n">run_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">or_vals</span><span class="p">[:</span><span class="mi">9</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

   <span class="n">mantid_mat</span> <span class="o">=</span> <span class="n">convert_from_sscanss_frame</span><span class="p">(</span><span class="n">run_mat</span><span class="p">)</span>
   <span class="n">new_string</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mantid_mat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span><span class="o">+</span><span class="n">trans_vals</span><span class="p">)</span>
   <span class="n">transformed_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_string</span><span class="p">)</span>

<span class="n">num_scans</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">goniometer_strings</span><span class="p">)</span><span class="o">//</span><span class="n">NUM_POINTS</span>

<span class="k">for</span> <span class="n">scan_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NUM_POINTS</span><span class="p">):</span>
   <span class="n">save_file</span> <span class="o">=</span> <span class="n">txt_file</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_mantid_point_</span><span class="si">{</span><span class="n">scan_ind</span><span class="si">}</span><span class="s2">.txt&quot;</span><span class="p">)</span>

   <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
      <span class="n">f</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">transformed_strings</span><span class="p">[</span><span class="n">scan_ind</span><span class="o">*</span><span class="n">num_scans</span><span class="p">:(</span><span class="n">scan_ind</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">num_scans</span><span class="p">])</span>
</pre></div>
</div>
</section>
</section>
<section id="absorption-correction">
<span id="absorptioncorrectionsection"></span><h2><a class="toc-backref" href="#id20" role="doc-backlink">Absorption Correction</a><a class="headerlink" href="#absorption-correction" title="Link to this heading">¶</a></h2>
<p>A consideration when performing texture analysis is to decide how to deal with attenuation and absorption. Depending upon the material being used,
the accuracy required, and the amount of time available, you may or may not want to apply a correction to the raw data to correct for neutron attenuation.
Mantid offers a suite of approaches to tackle this (<a class="reference internal" href="AbsorptionAndMultipleScattering.html#sample-corrections"><span class="std std-ref">Absorption and Multiple Scattering Corrections</span></a>), so to a certain extent this can be tailored to the use case, but here we
will discuss the methodology designed to replicate the functionality available within the user interface, making use of <a class="reference internal" href="../algorithms/MonteCarloAbsorption-v1.html#algm-montecarloabsorption"><span class="std std-ref">MonteCarloAbsorption v1</span></a>.</p>
<p>Below is a script that can be used to this end. The script is split into three sections - imports, experiment information, and execution. For most use cases
the only section needing attention is the experimental information. This section should be sufficiently annotated to explain how to use it, but should mirror
the user interface while providing more repeatable processing.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">AnalysisDataService</span> <span class="k">as</span> <span class="n">ADS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="kn">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">makedirs</span><span class="p">,</span> <span class="n">scandir</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.texture.TextureUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_all_files</span><span class="p">,</span> <span class="n">run_abs_corr</span>

<span class="c1">############### ENGINEERING DIFFRACTION INTERFACE ABSORPTION CORRECTION ANALOGUE #######################</span>

<span class="c1">######################### EXPERIMENTAL INFORMATION ########################################</span>

<span class="c1"># First, you need to specify your file directories, If you are happy to use the same root, from experiment</span>
<span class="c1"># to experiment, you can just change this experiment name.</span>
<span class="n">exp_name</span> <span class="o">=</span> <span class="s2">&quot;PostExp-ZrRingDiagScript&quot;</span>

<span class="c1"># otherwise set root directory here:</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;C:\Users\kcd17618\Engineering_Mantid\User\</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># next, specify the folder with the files you would like to apply the absorption correction to</span>
<span class="n">corr_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\kcd17618\Documents\dev\TextureCommisioning\Day3\ZrRing\DataFiles\Point2&quot;</span>

<span class="c1"># For texture, it is expected that you have a single ssmple shape, that is reorientated between runs.</span>
<span class="c1"># this is handled by having a reference workspace with the shape in its neutral position</span>
<span class="c1"># (position in the beamline when the goniometer is home)</span>
<span class="c1"># This reference workspace probably requires you to do some interacting and validating, so should be setup in the UI</span>
<span class="c1"># (Interfaces/Diffraction/Engineering Diffraction/Absorption Correction)</span>

<span class="c1"># if this is the case copy ref should be True and the ref_ws_path should be given</span>
<span class="c1"># otherwise, if set ref is true, it is assumed that the sample shapes are already present on the workspaces</span>
<span class="n">copy_ref</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">ref_ws_path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="s2">&quot;ReferenceWorkspaces&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">_reference_workspace.nxs&quot;</span><span class="p">)</span>

<span class="c1"># if using the reference you now need to reorientate the sample, this can be done using orientation files</span>
<span class="c1"># two standard types</span>

<span class="c1"># Euler Orientation (orient_file_is_euler = True)</span>
<span class="c1"># for this, euler_scheme and euler_axes_sense must be given to say which lab frame directions the goniometer axes are pointing along</span>
<span class="c1"># and where the rotations are counter-clockwise (1) or clockwise (-1)</span>

<span class="c1"># Matrix Orientation (orient_file_is_euler = False)</span>
<span class="c1"># for this the first 9 values in each row of the files are assumed to be flattened rotation matrix.</span>
<span class="c1"># These are used to directly reorientate the samples</span>
<span class="n">orientation_file</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\kcd17618\Documents\dev\TextureCommisioning\Day3\ZrRing\Sscanss\Split\Zirc_ring_pose_matrices_mantid_point_1.txt&quot;</span>
<span class="n">orient_file_is_euler</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">euler_scheme</span> <span class="o">=</span> <span class="s2">&quot;YXY&quot;</span>
<span class="n">euler_axes_sense</span> <span class="o">=</span> <span class="s2">&quot;1,-1,1&quot;</span>

<span class="c1"># Now you can specify information about the correction</span>
<span class="n">include_abs_corr</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># whether to perform the correction based on absorption</span>
<span class="n">monte_carlo_args</span> <span class="o">=</span> <span class="s2">&quot;SparseInstrument:True&quot;</span> <span class="c1"># what arguments to pass to MonteCarloAbsorption alg</span>
<span class="n">clear_ads_after</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># whether to remove the produced files from the ADS to free up RAM</span>
<span class="n">gauge_vol_preset</span> <span class="o">=</span> <span class="s2">&quot;4mmCube&quot;</span> <span class="c1"># or &quot;Custom&quot; # the gauge volume being used</span>
<span class="n">gauge_vol_shape_file</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># or &quot;path/to/xml&quot; # a custom gauge volume shape file</span>

<span class="c1"># There is also the option to output an attenuation table alongside correcting the data</span>
<span class="c1"># This will return a table of the attenuation coefficient at the point specified</span>
<span class="n">include_atten_table</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">eval_point</span> <span class="o">=</span> <span class="s2">&quot;2.00&quot;</span>
<span class="n">eval_units</span> <span class="o">=</span> <span class="s2">&quot;dSpacing&quot;</span> <span class="c1">#must be a valid argument for ConvertUnits</span>

<span class="c1"># Finally, you can add a divergence correction to the data, this is still a work in progress, so keep False for now</span>
<span class="n">include_div_corr</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">div_hoz</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">div_vert</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">det_hoz</span> <span class="o">=</span> <span class="mf">0.02</span>

<span class="c1">######################### RUN SCRIPT ########################################</span>

<span class="c1"># load the ref workspace</span>
<span class="n">ref_ws_str</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">ref_ws_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">Load</span><span class="p">(</span><span class="n">Filename</span> <span class="o">=</span> <span class="n">ref_ws_path</span><span class="p">,</span> <span class="n">OutputWorkspace</span> <span class="o">=</span> <span class="n">ref_ws_str</span><span class="p">)</span>

<span class="c1"># load data workspaces</span>
<span class="n">corr_wss</span> <span class="o">=</span> <span class="n">find_all_files</span><span class="p">(</span><span class="n">corr_dir</span><span class="p">)</span>
<span class="n">wss</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">corr_wss</span><span class="p">]</span>
<span class="k">for</span> <span class="n">iws</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">wss</span><span class="p">):</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">ADS</span><span class="o">.</span><span class="n">doesExist</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
      <span class="n">Load</span><span class="p">(</span><span class="n">Filename</span> <span class="o">=</span> <span class="n">corr_wss</span><span class="p">[</span><span class="n">iws</span><span class="p">],</span> <span class="n">OutputWorkspace</span><span class="o">=</span> <span class="n">ws</span><span class="p">)</span>

<span class="c1"># run script</span>
<span class="n">run_abs_corr</span><span class="p">(</span><span class="n">wss</span> <span class="o">=</span> <span class="n">wss</span><span class="p">,</span>
            <span class="n">ref_ws</span> <span class="o">=</span> <span class="n">ref_ws_str</span><span class="p">,</span>
            <span class="n">orientation_file</span> <span class="o">=</span> <span class="n">orientation_file</span><span class="p">,</span>
            <span class="n">orient_file_is_euler</span> <span class="o">=</span> <span class="n">orient_file_is_euler</span><span class="p">,</span>
            <span class="n">euler_scheme</span> <span class="o">=</span> <span class="n">euler_scheme</span><span class="p">,</span>
            <span class="n">euler_axes_sense</span> <span class="o">=</span> <span class="n">euler_axes_sense</span><span class="p">,</span>
            <span class="n">copy_ref</span> <span class="o">=</span> <span class="n">copy_ref</span><span class="p">,</span>
            <span class="n">include_abs_corr</span> <span class="o">=</span> <span class="n">include_abs_corr</span><span class="p">,</span>
            <span class="n">monte_carlo_args</span> <span class="o">=</span> <span class="n">monte_carlo_args</span><span class="p">,</span>
            <span class="n">gauge_vol_preset</span> <span class="o">=</span> <span class="n">gauge_vol_preset</span><span class="p">,</span>
            <span class="n">gauge_vol_shape_file</span> <span class="o">=</span> <span class="n">gauge_vol_shape_file</span><span class="p">,</span>
            <span class="n">include_atten_table</span> <span class="o">=</span> <span class="n">include_atten_table</span><span class="p">,</span>
            <span class="n">eval_point</span> <span class="o">=</span> <span class="n">eval_point</span><span class="p">,</span>
            <span class="n">eval_units</span> <span class="o">=</span> <span class="n">eval_units</span><span class="p">,</span>
            <span class="n">exp_name</span> <span class="o">=</span> <span class="n">exp_name</span><span class="p">,</span>
            <span class="n">root_dir</span> <span class="o">=</span> <span class="n">root_dir</span><span class="p">,</span>
            <span class="n">include_div_corr</span> <span class="o">=</span> <span class="n">include_div_corr</span><span class="p">,</span>
            <span class="n">div_hoz</span> <span class="o">=</span> <span class="n">div_hoz</span><span class="p">,</span>
            <span class="n">div_vert</span> <span class="o">=</span> <span class="n">div_vert</span><span class="p">,</span>
            <span class="n">det_hoz</span> <span class="o">=</span> <span class="n">det_hoz</span><span class="p">,</span>
            <span class="n">clear_ads_after</span> <span class="o">=</span> <span class="n">clear_ads_after</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="focusing">
<h2><a class="toc-backref" href="#id21" role="doc-backlink">Focusing</a><a class="headerlink" href="#focusing" title="Link to this heading">¶</a></h2>
<p>Regardless of whether absorption correction has been applied (at the very least the absorption correction script should probably be run with <code class="docutils literal notranslate"><span class="pre">include_abs_corr</span> <span class="pre">=</span> <span class="pre">False</span></code>,
in order to apply the sample shape and orientations), some focusing of data is likely required for creating pole figures. In principle, unfocussed data could be used,
but this would be rather slow due to the fitting of peaks on each spectra, and this would not necessarily provide meaningful improvement in spatial resolution. As far as
ENGINX is concerned, grouping any more finely than the block level is mostly diminishing returns. The below script can be used to generate some custom groupings at
the module or block level, and could be modified for more exotic groupings beyond this, but there are standard groupings available as well.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_detector_grouping_string</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="n">group_by</span><span class="p">):</span>
   <span class="n">info</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">componentInfo</span><span class="p">()</span>
   <span class="n">detinfo</span> <span class="o">=</span> <span class="n">ws</span><span class="o">.</span><span class="n">detectorInfo</span><span class="p">()</span>
   <span class="n">dets</span> <span class="o">=</span> <span class="n">detinfo</span><span class="o">.</span><span class="n">detectorIDs</span><span class="p">()</span>
   <span class="n">instr_dets</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">detectorsInSubtree</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">root</span><span class="p">())</span>

   <span class="k">def</span><span class="w"> </span><span class="nf">get_det_id</span><span class="p">(</span><span class="n">comp_ind</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">instr_dets</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">dets</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">instr_dets</span> <span class="o">==</span> <span class="n">comp_ind</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span>

   <span class="n">nbi</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">indexOfAny</span><span class="p">(</span><span class="s2">&quot;NorthBank&quot;</span><span class="p">)</span>
   <span class="n">sbi</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">indexOfAny</span><span class="p">(</span><span class="s2">&quot;SouthBank&quot;</span><span class="p">)</span>


   <span class="n">nbmi</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">nbi</span><span class="p">)</span>
   <span class="n">sbmi</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">sbi</span><span class="p">)</span>

   <span class="n">nbmbi</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nbm</span><span class="p">))</span> <span class="k">for</span> <span class="n">nbm</span> <span class="ow">in</span> <span class="n">nbmi</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
   <span class="n">sbmbi</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">info</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sbm</span><span class="p">))</span> <span class="k">for</span> <span class="n">sbm</span> <span class="ow">in</span> <span class="n">sbmi</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
   <span class="k">if</span> <span class="n">group_by</span> <span class="o">==</span> <span class="s2">&quot;module&quot;</span><span class="p">:</span>
      <span class="n">n_mods</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">get_det_id</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">instr_dets</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">detectorsInSubtree</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nbm</span><span class="p">))])</span> <span class="k">for</span> <span class="n">nbm</span> <span class="ow">in</span>
            <span class="n">nbmi</span><span class="p">])</span>
      <span class="n">s_mods</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">get_det_id</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">instr_dets</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">detectorsInSubtree</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sbm</span><span class="p">))])</span> <span class="k">for</span> <span class="n">sbm</span> <span class="ow">in</span>
            <span class="n">sbmi</span><span class="p">])</span>
      <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n_mods</span><span class="p">,</span> <span class="n">s_mods</span><span class="p">])</span>
   <span class="k">if</span> <span class="n">group_by</span> <span class="o">==</span> <span class="s2">&quot;block&quot;</span><span class="p">:</span>
      <span class="n">n_blocks</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">get_det_id</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">instr_dets</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">detectorsInSubtree</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nbm</span><span class="p">))])</span> <span class="k">for</span> <span class="n">nbm</span> <span class="ow">in</span>
            <span class="n">nbmbi</span><span class="p">])</span>
      <span class="n">s_blocks</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">get_det_id</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dets</span><span class="p">,</span> <span class="n">instr_dets</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">info</span><span class="o">.</span><span class="n">detectorsInSubtree</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">sbm</span><span class="p">))])</span> <span class="k">for</span> <span class="n">sbm</span> <span class="ow">in</span>
            <span class="n">sbmbi</span><span class="p">])</span>
      <span class="k">return</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n_blocks</span><span class="p">,</span> <span class="n">s_blocks</span><span class="p">])</span>

<span class="n">ws</span> <span class="o">=</span> <span class="n">LoadEmptyInstrument</span><span class="p">(</span><span class="n">InstrumentName</span> <span class="o">=</span> <span class="s2">&quot;ENGINX&quot;</span><span class="p">)</span>

<span class="n">block_string</span> <span class="o">=</span> <span class="n">get_detector_grouping_string</span><span class="p">(</span><span class="n">ws</span><span class="p">,</span> <span class="s2">&quot;block&quot;</span><span class="p">)</span>

<span class="n">det_group</span> <span class="o">=</span> <span class="n">CreateGroupingWorkspace</span><span class="p">(</span><span class="n">InputWorkspace</span> <span class="o">=</span> <span class="n">ws</span><span class="p">,</span> <span class="n">CustomGroupingString</span> <span class="o">=</span> <span class="n">block_string</span><span class="p">,</span> <span class="n">OutputWorkspace</span> <span class="o">=</span> <span class="s2">&quot;det_group&quot;</span><span class="p">)</span>

<span class="n">CreateGroupingWorkspace</span><span class="p">(</span><span class="n">InstrumentName</span><span class="o">=</span><span class="s1">&#39;ENGINX&#39;</span><span class="p">,</span>
                        <span class="n">ComponentName</span><span class="o">=</span><span class="s1">&#39;ENGIN-X&#39;</span><span class="p">,</span>
                        <span class="n">CustomGroupingString</span><span class="o">=</span><span class="n">block_string</span><span class="p">,</span>
                        <span class="n">OutputWorkspace</span> <span class="o">=</span> <span class="s2">&quot;det_group&quot;</span><span class="p">)</span>

<span class="n">SaveCalFile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;path\to\cal\block.cal&quot;</span><span class="p">,</span> <span class="n">GroupingWorkspace</span> <span class="o">=</span> <span class="s2">&quot;det_group&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>These cal files can be provided as a <code class="docutils literal notranslate"><span class="pre">grouping_filepath</span></code> if desired, or used to calibrate in the user interface and the resultant <code class="docutils literal notranslate"><span class="pre">prm</span></code> file can be used for focusing.</p>
<p>If using a standard grouping, no <code class="docutils literal notranslate"><span class="pre">grouping_filepath</span></code> or <code class="docutils literal notranslate"><span class="pre">prm_filepath</span></code> is required, and simply the string (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;Texture30&quot;</span></code>) is needed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">AnalysisDataService</span> <span class="k">as</span> <span class="n">ADS</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.texture.TextureUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_all_files</span><span class="p">,</span> <span class="n">run_focus_script</span>

<span class="c1">############### ENGINEERING DIFFRACTION INTERFACE FOCUS ANALOGUE #######################</span>

<span class="c1">######################### EXPERIMENTAL INFORMATION ########################################</span>

<span class="c1"># First, you need to specify your file directories, If you are happy to use the same root, from experiment</span>
<span class="c1"># to experiment, you can just change this experiment name.</span>

<span class="n">exp_name</span> <span class="o">=</span> <span class="s2">&quot;Example&quot;</span>

<span class="c1"># otherwise set root directory here:</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;C:\Users\Name\Engineering_Mantid\User\</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># next, specify the folder with the files you would like to focus</span>
<span class="c1"># (if you are using the standard scripts this might not need to change)</span>
<span class="n">data_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">root_dir</span><span class="si">}</span><span class="s2">\AbsorptionCorrection&quot;</span>

<span class="c1"># fill in the file paths for the vanadium and ceria runs (just run numbers might work if you are setup into the file system)</span>
<span class="n">van_run</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\Name\DataFiles\ENGINX00361838.nxs&quot;</span>
<span class="n">ceria_run</span> <span class="o">=</span> <span class="s2">&quot;305738&quot;</span>

<span class="c1"># set the path to the grouping file created by calibration</span>
<span class="n">prm_path</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># fr&quot;{root}\Calibration\ENGINX_305738_Texture30.prm&quot;</span>
<span class="n">grouping</span> <span class="o">=</span> <span class="s2">&quot;Texture30&quot;</span> <span class="c1"># use &quot;Custom&quot; if you want to provide custom grouping</span>
<span class="n">groupingfile_path</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># r&quot;C:\Users\Name\block.cal&quot; # if a custom cal/xml grouping file is desired</span>

<span class="c1"># Define some file paths, can be found in the interface settings</span>
<span class="n">full_instr_calib</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\mantid\scripts\Engineering\calib\ENGINX_full_instrument_calibration_193749.nxs&quot;</span>

<span class="c1">######################### RUN SCRIPT ########################################</span>

<span class="n">run_files</span> <span class="o">=</span> <span class="n">find_all_files</span><span class="p">(</span><span class="n">data_dir</span><span class="p">)</span>

<span class="n">run_focus_script</span><span class="p">(</span><span class="n">wss</span> <span class="o">=</span> <span class="n">run_files</span><span class="p">,</span>
               <span class="n">focus_dir</span> <span class="o">=</span> <span class="n">root_dir</span><span class="p">,</span>
               <span class="n">van_run</span> <span class="o">=</span> <span class="n">van_run</span><span class="p">,</span>
               <span class="n">ceria_run</span> <span class="o">=</span> <span class="n">ceria_run</span><span class="p">,</span>
               <span class="n">full_instr_calib</span> <span class="o">=</span> <span class="n">full_instr_calib</span><span class="p">,</span>
               <span class="n">grouping</span> <span class="o">=</span> <span class="n">grouping</span><span class="p">,</span>
               <span class="n">prm_path</span> <span class="o">=</span> <span class="n">prm_path</span><span class="p">,</span>
               <span class="n">groupingfile_path</span> <span class="o">=</span> <span class="n">groupingfile_path</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="fitting">
<h2><a class="toc-backref" href="#id22" role="doc-backlink">Fitting</a><a class="headerlink" href="#fitting" title="Link to this heading">¶</a></h2>
<p>Once the data has been focused, it is most likely that the desire is to extract some fitted parameters from these focused spectra. The following script can be used to
do this. This script will fit a BackToBackExponential to each peak provided in the <code class="docutils literal notranslate"><span class="pre">peaks</span></code> list and save the associated parameters into individual table workspaces.
Additionally to fitting the peak, the table will also contain a numerical integration of the peak window after subtraction of a linear background (<code class="docutils literal notranslate"><span class="pre">I_est</span></code>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">AnalysisDataService</span> <span class="k">as</span> <span class="n">ADS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os</span><span class="w"> </span><span class="kn">import</span> <span class="n">path</span><span class="p">,</span> <span class="n">makedirs</span><span class="p">,</span> <span class="n">scandir</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.texture.TextureUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_all_files</span><span class="p">,</span> <span class="n">fit_all_peaks</span><span class="p">,</span> <span class="n">mk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.common.calibration_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">CalibrationInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.EnggUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">GROUP</span>

<span class="c1">############### ENGINEERING DIFFRACTION INTERFACE FITTING ANALOGUE #######################</span>

<span class="c1">######################### EXPERIMENTAL INFORMATION ########################################</span>

<span class="c1"># First, you need to specify your file directories, If you are happy to use the same root, from experiment</span>
<span class="c1"># to experiment, you can just change this experiment name.</span>
<span class="n">exp_name</span> <span class="o">=</span> <span class="s2">&quot;Example&quot;</span>

<span class="c1"># otherwise set root directory here:</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;path\to\User\</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Next the folder contraining the workspaces you want to fit</span>
<span class="n">file_folder</span> <span class="o">=</span> <span class="s2">&quot;Focus&quot;</span>
<span class="c1"># These are likely within a sub-folder specified by the detector grouping</span>
<span class="n">grouping</span> <span class="o">=</span> <span class="s2">&quot;Texture30&quot;</span>
<span class="n">prm_path</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">groupingfile_path</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># You also need to specify a name for the folder the fit parameters will be saved in</span>
<span class="n">fit_save_folder</span> <span class="o">=</span> <span class="s2">&quot;ScriptFitParameters-FitTest&quot;</span>

<span class="c1"># Provide a list of peaks that you want to be fit within the spectra</span>
<span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.03</span><span class="p">,</span><span class="mf">1.44</span><span class="p">,</span> <span class="mf">1.17</span><span class="p">,</span> <span class="mf">0.91</span><span class="p">]</span> <span class="c1"># steel</span>

<span class="c1"># The fitting has a couple of parameters that deal with when peaks are missing as a result of the texture</span>
<span class="c1"># The first parameter is 1_over_sigma_thresh - this determines the minimum value of I/sigma for a fit to be considered as for a valid peak</span>
<span class="c1"># any invalid peak will have parameters set to nan by default, but these nans can be overwritten by no_fit_value_dicts and nan_replacement</span>
<span class="c1"># no_fit_value_dict takes fitted parameter names and allows you to specify what the unfit value should be eg. {&quot;I&quot;:0.0} - if you can&#39;t fit intensity</span>
<span class="c1"># set the value directly to 0.0</span>
<span class="c1"># nan_replacement then happens after this, if a nan_replacement method is given any parameters without an unfit_value provided will have nans replaced</span>
<span class="c1"># either with &quot;zeros&quot;, or with the min/max/mean value of that parameter (Note: if all the values are nan, the value will remain nan)</span>

<span class="n">i_over_sigma_thresh</span> <span class="o">=</span> <span class="mf">3.0</span>
<span class="n">no_fit_value_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;I_est&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">}</span>
<span class="n">nan_replacement</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>

<span class="c1">######################### RUN SCRIPT ########################################</span>

<span class="c1"># create output directory</span>
<span class="n">fit_save_dir</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">fit_save_folder</span><span class="p">)</span>
<span class="n">mk</span><span class="p">(</span><span class="n">fit_save_dir</span><span class="p">)</span>

<span class="c1"># find and load peaks</span>

<span class="c1"># get grouping directory name</span>
<span class="n">calib_info</span> <span class="o">=</span> <span class="n">CalibrationInfo</span><span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">GROUP</span><span class="p">(</span><span class="n">grouping</span><span class="p">))</span>
<span class="k">if</span> <span class="n">groupingfile_path</span><span class="p">:</span>
   <span class="n">calib_info</span><span class="o">.</span><span class="n">set_grouping_file</span><span class="p">(</span><span class="n">groupingfile_path</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">prm_path</span><span class="p">:</span>
   <span class="n">calib_info</span><span class="o">.</span><span class="n">set_prm_filepath</span><span class="p">(</span><span class="n">prm_path</span><span class="p">)</span>
<span class="n">group_folder</span> <span class="o">=</span> <span class="n">calib_info</span><span class="o">.</span><span class="n">get_group_suffix</span><span class="p">()</span>
<span class="n">focussed_data_dir</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">file_folder</span><span class="p">,</span> <span class="n">group_folder</span><span class="p">,</span> <span class="s2">&quot;CombinedFiles&quot;</span><span class="p">)</span>
<span class="n">focus_ws_paths</span> <span class="o">=</span> <span class="n">find_all_files</span><span class="p">(</span><span class="n">focussed_data_dir</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">focus_wss</span> <span class="o">=</span> <span class="p">[</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">focus_ws_paths</span><span class="p">]</span>
<span class="k">for</span> <span class="n">iws</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">focus_wss</span><span class="p">):</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">ADS</span><span class="o">.</span><span class="n">doesExist</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
      <span class="n">Load</span><span class="p">(</span><span class="n">Filename</span> <span class="o">=</span> <span class="n">focus_ws_paths</span><span class="p">[</span><span class="n">iws</span><span class="p">],</span> <span class="n">OutputWorkspace</span><span class="o">=</span> <span class="n">ws</span><span class="p">)</span>


<span class="c1"># execute the fitting</span>
<span class="n">fit_all_peaks</span><span class="p">(</span><span class="n">focus_wss</span><span class="p">,</span> <span class="n">peaks</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="n">fit_save_dir</span><span class="p">,</span> <span class="n">i_over_sigma_thresh</span> <span class="o">=</span> <span class="n">i_over_sigma_thresh</span><span class="p">,</span> <span class="n">nan_replacement</span> <span class="o">=</span> <span class="n">nan_replacement</span><span class="p">,</span> <span class="n">no_fit_value_dict</span> <span class="o">=</span> <span class="n">no_fit_value_dict</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pole-figure-creation">
<h2><a class="toc-backref" href="#id23" role="doc-backlink">Pole Figure creation</a><a class="headerlink" href="#pole-figure-creation" title="Link to this heading">¶</a></h2>
<p>Finally, the focused workspaces and the parameter workspaces can be combined to create the pole figures of interest. The below script can be used to produce a collection
of pole figures over a set of different peaks and parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># import mantid algorithms, numpy and matplotlib</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.simpleapi</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">mantid.api</span><span class="w"> </span><span class="kn">import</span> <span class="n">AnalysisDataService</span> <span class="k">as</span> <span class="n">ADS</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.texture.TextureUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_all_files</span><span class="p">,</span> <span class="n">create_pf_loop</span><span class="p">,</span> <span class="n">get_xtal_structure</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.common.calibration_info</span><span class="w"> </span><span class="kn">import</span> <span class="n">CalibrationInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">Engineering.EnggUtils</span><span class="w"> </span><span class="kn">import</span> <span class="n">GROUP</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="c1">############### ENGINEERING DIFFRACTION INTERFACE POLE FIGURE ANALOGUE #######################</span>

<span class="c1">######################### EXPERIMENTAL INFORMATION ########################################</span>
<span class="c1"># First, you need to specify your file directories, If you are happy to use the same root, from experiment</span>
<span class="c1"># to experiment, you can just change this experiment name.</span>
<span class="n">exp_name</span> <span class="o">=</span> <span class="s2">&quot;PostExp-SteelCentre&quot;</span>

<span class="c1"># otherwise set root directory here:</span>
<span class="n">save_root</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\kcd17618\Engineering_Mantid&quot;</span>
<span class="n">root_dir</span> <span class="o">=</span> <span class="sa">fr</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">save_root</span><span class="si">}</span><span class="s2">\User\</span><span class="si">{</span><span class="n">exp_name</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="n">ws_folder</span> <span class="o">=</span> <span class="s2">&quot;Focus&quot;</span>
<span class="n">fit_save_folder</span> <span class="o">=</span> <span class="s2">&quot;ScriptFitParameters-New&quot;</span>
<span class="c1"># define the peaks of interest, NOTE these must correspond to sub folders in the fit directory</span>
<span class="n">peaks</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2.03</span><span class="p">,</span><span class="mf">1.44</span><span class="p">,</span> <span class="mf">1.17</span><span class="p">]</span>
<span class="c1"># define the columns you would like to create pole figures for</span>
<span class="n">readout_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="s2">&quot;X0&quot;</span><span class="p">]</span>
<span class="c1"># you need to specify the detector grouping</span>
<span class="n">grouping</span> <span class="o">=</span> <span class="s2">&quot;Texture30&quot;</span>
<span class="c1"># and some grouping path if not using a standard</span>
<span class="n">prm_path</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">groupingfile_path</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1"># and the type of projection to plot</span>
<span class="n">projection_method</span> <span class="o">=</span> <span class="s2">&quot;Azimuthal&quot;</span>

<span class="c1"># you need to define the orientation of the intrinsic sample directions when the sample orientation matrix == I (no rotation)</span>
<span class="c1"># this should be the same as the reference state used in the absorption correction</span>
<span class="c1">#r2 = np.sqrt(2)/2</span>
<span class="n">dir1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">dir2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1"># projection axis</span>
<span class="n">dir3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="c1"># you can also supply names for these three directions</span>
<span class="n">dir_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;RD&quot;</span><span class="p">,</span> <span class="s2">&quot;ND&quot;</span><span class="p">,</span> <span class="s2">&quot;TD&quot;</span><span class="p">]</span>

<span class="c1"># set whether you would like the plotted pole figure to be a scatter of experimental points or whether you would like to apply gaussian smoothing and</span>
<span class="c1"># plot a contour representation</span>
<span class="n">scatter</span> <span class="o">=</span> <span class="s2">&quot;both&quot;</span>
<span class="c1"># if contour, what should the kernel size of the gaussian be</span>
<span class="n">kernel</span> <span class="o">=</span> <span class="mf">6.0</span>

<span class="c1"># do you want to include a scattering power correction</span>
<span class="n">include_scatt_power</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># if so what is the crystal structure, defined either by giving a cif file or supplying the lattice, space group and basis</span>
<span class="n">xtal_input</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># &quot;cif&quot;/&quot;array&quot;/&quot;string&quot;</span>
<span class="n">xtal_args</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># for input &quot;cif&quot;, require the cif filepath, for &quot;array&quot; array of lattice parameters, space group, basis</span>
<span class="c1"># for &quot;string&quot; lattice parameter string, space group and basis</span>

<span class="c1"># if you have set a crystal, you can also provide a set of hkls, the hkl_peaks dictionary is a useful way of assigning the peaks</span>
<span class="n">hkl_peaks</span> <span class="o">=</span> <span class="p">{</span><span class="mf">1.17</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="mf">1.44</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="mf">2.03</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)}</span> <span class="c1">#Fe</span>

<span class="n">chi2_thresh</span> <span class="o">=</span> <span class="mf">0.0</span>   <span class="c1"># max value of Chi^2 to be included as a point in the table</span>
<span class="n">peak_thresh</span> <span class="o">=</span> <span class="mf">0.01</span>   <span class="c1"># max difference from either the HKL specified or the mean X0</span>
<span class="n">scat_vol_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">)</span> <span class="c1"># for now, can assume the gauge vol will be centred on origin</span>

<span class="c1">######################### RUN SCRIPT ########################################</span>


<span class="c1"># get grouping directory name</span>
<span class="n">calib_info</span> <span class="o">=</span> <span class="n">CalibrationInfo</span><span class="p">(</span><span class="n">group</span> <span class="o">=</span> <span class="n">GROUP</span><span class="p">(</span><span class="n">grouping</span><span class="p">))</span>
<span class="k">if</span> <span class="n">groupingfile_path</span><span class="p">:</span>
   <span class="n">calib_info</span><span class="o">.</span><span class="n">set_grouping_file</span><span class="p">(</span><span class="n">groupingfile_path</span><span class="p">)</span>
<span class="k">elif</span> <span class="n">prm_path</span><span class="p">:</span>
   <span class="n">calib_info</span><span class="o">.</span><span class="n">set_prm_filepath</span><span class="p">(</span><span class="n">prm_path</span><span class="p">)</span>
<span class="n">group_folder</span> <span class="o">=</span> <span class="n">calib_info</span><span class="o">.</span><span class="n">get_group_suffix</span><span class="p">()</span>
<span class="n">focussed_data_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">ws_folder</span><span class="p">,</span> <span class="n">group_folder</span><span class="p">,</span> <span class="s2">&quot;CombinedFiles&quot;</span><span class="p">)</span>
<span class="n">focus_ws_paths</span> <span class="o">=</span> <span class="n">find_all_files</span><span class="p">(</span><span class="n">focussed_data_dir</span><span class="p">)</span>
<span class="n">focus_wss</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">focus_ws_paths</span><span class="p">]</span>
<span class="k">for</span> <span class="n">iws</span><span class="p">,</span> <span class="n">ws</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">focus_wss</span><span class="p">):</span>
   <span class="k">if</span> <span class="ow">not</span> <span class="n">ADS</span><span class="o">.</span><span class="n">doesExist</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
      <span class="n">Load</span><span class="p">(</span><span class="n">Filename</span> <span class="o">=</span> <span class="n">focus_ws_paths</span><span class="p">[</span><span class="n">iws</span><span class="p">],</span> <span class="n">OutputWorkspace</span><span class="o">=</span> <span class="n">ws</span><span class="p">)</span>

<span class="n">fit_load_dirs</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">fit_save_folder</span><span class="p">,</span> <span class="n">group_folder</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">peak</span><span class="p">))</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>

<span class="n">hkls</span> <span class="o">=</span> <span class="p">[</span><span class="n">hkl_peaks</span><span class="p">[</span><span class="n">peak</span><span class="p">]</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">peaks</span><span class="p">]</span>

<span class="n">fit_param_wss</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">ifit</span><span class="p">,</span> <span class="n">fit_folder</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fit_load_dirs</span><span class="p">):</span>
   <span class="c1"># get fit params</span>
   <span class="n">fit_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">fit_folder</span><span class="p">)</span>
   <span class="n">fit_wss</span> <span class="o">=</span> <span class="n">find_all_files</span><span class="p">(</span><span class="n">fit_dir</span><span class="p">)</span>
   <span class="n">param_wss</span> <span class="o">=</span> <span class="p">[</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">fp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fp</span> <span class="ow">in</span> <span class="n">fit_wss</span><span class="p">]</span>
   <span class="n">fit_param_wss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param_wss</span><span class="p">)</span>
   <span class="k">for</span> <span class="n">iparam</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_wss</span><span class="p">):</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ADS</span><span class="o">.</span><span class="n">doesExist</span><span class="p">(</span><span class="n">param</span><span class="p">):</span>
            <span class="n">Load</span><span class="p">(</span><span class="n">Filename</span><span class="o">=</span><span class="n">fit_wss</span><span class="p">[</span><span class="n">iparam</span><span class="p">],</span> <span class="n">OutputWorkspace</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>

<span class="n">create_pf_loop</span><span class="p">(</span><span class="n">wss</span> <span class="o">=</span> <span class="n">focus_wss</span><span class="p">,</span>
               <span class="n">param_wss</span> <span class="o">=</span> <span class="n">fit_param_wss</span><span class="p">,</span>
               <span class="n">include_scatt_power</span> <span class="o">=</span> <span class="n">include_scatt_power</span><span class="p">,</span>
               <span class="n">xtal_input</span> <span class="o">=</span> <span class="n">xtal_input</span><span class="p">,</span>
               <span class="n">xtal_args</span> <span class="o">=</span> <span class="n">xtal_args</span><span class="p">,</span>
               <span class="n">readout_columns</span> <span class="o">=</span> <span class="n">readout_columns</span><span class="p">,</span>
               <span class="n">hkls</span> <span class="o">=</span> <span class="n">hkls</span><span class="p">,</span>
               <span class="n">dir1</span> <span class="o">=</span> <span class="n">dir1</span><span class="p">,</span>
               <span class="n">dir2</span> <span class="o">=</span> <span class="n">dir2</span><span class="p">,</span>
               <span class="n">dir3</span> <span class="o">=</span> <span class="n">dir3</span><span class="p">,</span>
               <span class="n">dir_names</span> <span class="o">=</span> <span class="n">dir_names</span><span class="p">,</span>
               <span class="n">scatter</span> <span class="o">=</span> <span class="n">scatter</span><span class="p">,</span>
               <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">,</span>
               <span class="n">scat_vol_pos</span> <span class="o">=</span> <span class="n">scat_vol_pos</span><span class="p">,</span>
               <span class="n">chi2_thresh</span> <span class="o">=</span> <span class="n">chi2_thresh</span><span class="p">,</span>
               <span class="n">peak_thresh</span> <span class="o">=</span> <span class="n">peak_thresh</span><span class="p">,</span>
               <span class="n">save_root</span> <span class="o">=</span> <span class="n">save_root</span><span class="p">,</span>
               <span class="n">exp_name</span> <span class="o">=</span> <span class="n">exp_name</span><span class="p">,</span>
               <span class="n">projection_method</span> <span class="o">=</span> <span class="n">projection_method</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="references">
<h1><a class="toc-backref" href="#id24" role="doc-backlink">References</a><a class="headerlink" href="#references" title="Link to this heading">¶</a></h1>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="detbanks" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Malamud, F., Santisteban, J. R., Vicente Alvarez, M. A., Bolmaro, R., Kelleher, J., Kabra, S. &amp; Kockelmann, W. (2014). Texture analysis with a time-of-flight neutron strain scanner. J. Appl. Cryst. 47, 1337–1354 doi:10.1107/S1600576714012710</p>
</aside>
<aside class="footnote brackets" id="sscanss" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">2</a><span class="fn-bracket">]</span></span>
<p><cite>&lt;https://isisneutronmuon.github.io/SScanSS-2&gt;</cite></p>
</aside>
</aside>
<p><strong>Category</strong>: <a class="reference external" href="../api/python/mantid/api/categories/Concepts.html">Concepts</a></p>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
      <ul class="nav navbar-nav" style=" float: right;">
      
      
          
            
  <li>
    <a href="TableWorkspaces.html" title="Previous Chapter: Table Workspaces"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; Table Workspaces</span>
    </a>
  </li>
  <li>
    <a href="UnitFactory.html" title="Next Chapter: Units"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">Units &raquo;</span>
    </a>
  </li>
          
       
          <li><a href="#">Back to top</a></li>
       </ul>
    <p>
    </p>
  </div>
</footer>
  </body>
</html>